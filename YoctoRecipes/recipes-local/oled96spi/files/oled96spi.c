/******************************************************************************
 *
 *   Copyright (C) 2011  Intel Corporation. All rights reserved.
 *
 *   SPDX-License-Identifier: GPL-2.0-only
 *
 *****************************************************************************/

#include <linux/types.h>
#include <linux/kernel.h>
#include <linux/delay.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/errno.h>
#include <linux/gpio.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/of_gpio.h>
#include <linux/semaphore.h>
#include <linux/timer.h>
#include <linux/spi/spi.h>
#include <linux/fs.h>
#include <asm/mach/map.h>
#include <asm/uaccess.h>
#include <asm/io.h>

//#define CS_GPIO

#if 0
static int mp_find_node_by_phandle;
module_param(mp_find_node_by_phandle, int, 0660);
MODULE_PARMDESC(mp_find_node_by_phandle, "Set to [0, 1];\n0=>find by name; 1=>find by phandle;");
#endif

const int OLED96_COUNT = 1;
const char* const OLED96_NAME = "oled96spi";

const int OLED_CMD = 0;
const int OLED_DATA = 1;

static u8 OLED_GRAM[144][8];
unsigned char BMP1[] = {};

unsigned char BMP2[] =
{
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x84,0xC4,0x66,0x36,0x3E,0x1C,0x3C,0x7C,0xE6,0x06,0x06,0x03,0x03,0x03,
	0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x06,0x06,0x06,0xFC,0x3C,0x1C,0x3E,
	0x3E,0x66,0xC6,0x84,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x40,0x60,0xE0,0x00,0x00,0xE0,0x20,0xE0,0xC0,0xC0,0x60,0x20,0xE0,0x00,
	0x20,0x20,0xE0,0x60,0x00,0x80,0xE0,0xE0,0x00,0x00,0xE0,0x00,0x00,0xE0,0xE0,0x00,
	0xE0,0x20,0xE0,0x40,0xC0,0xE0,0x20,0x20,0xE0,0xC0,0xC0,0xE0,0x20,0xE0,0x00,0x00,
	0xC0,0x60,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0xF8,0xF8,
	0xFE,0x77,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0xF8,0xF8,0xF8,0x70,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x07,0x06,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x0C,0x0F,0x0C,0x00,0x0D,0x0D,0x07,0x03,0x00,0x0D,0x0D,0x07,0x00,
	0x00,0x06,0x03,0x00,0x04,0x07,0x02,0x03,0x07,0x00,0x07,0x0C,0x0C,0x07,0x03,0x00,
	0x07,0x01,0x07,0x04,0x03,0x06,0x0C,0x0C,0x07,0x03,0x07,0x07,0x01,0x07,0x04,0x0E,
	0x03,0x02,0x03,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0xFE,0x07,0x03,0x01,
	0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x01,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
	0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x02,0x06,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x20,0xE8,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x28,0xDC,0x68,0x98,
	0x78,0xE8,0x38,0x00,0x00,0xF0,0x1C,0xF0,0x20,0xDC,0x10,0xF0,0x00,0x00,0x00,0x20,
	0x70,0xD0,0x90,0x00,0xF0,0x90,0x90,0x60,0x00,0xF0,0x00,0x00,0x00,0x20,0x10,0xD0,
	0x30,0xFC,0x10,0x10,0x10,0x00,0x40,0x78,0x78,0xC0,0x30,0xCC,0x30,0xA0,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,
	0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x07,0x04,0x04,0x04,0x07,0x04,0x04,0x00,0x00,0x00,0x07,0x06,0x03,
	0x00,0x07,0x04,0x00,0x00,0x07,0x00,0x07,0x00,0x00,0x04,0x07,0x00,0x00,0x00,0x02,
	0x06,0x06,0x03,0x00,0x07,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x01,0x05,
	0x07,0x03,0x03,0x07,0x05,0x00,0x01,0x05,0x07,0x01,0x07,0x05,0x07,0x04,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x0F,0x3E,0xF0,0x80,
	0x03,0x0E,0x38,0x70,0xC0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
	0x80,0xC0,0x60,0x30,0x1C,0x07,0x80,0xF0,0x7E,0x0F,0x01,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,
	0x07,0x1C,0x38,0x70,0x60,0xC1,0xC3,0x87,0x06,0x0E,0x0C,0x1C,0x1C,0x18,0x38,0x38,
	0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x1C,0x1C,0x0C,0x0E,0x06,0x87,0xC3,
	0xC1,0xE0,0x70,0x38,0x1C,0x0F,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x03,0x07,0x06,0x06,0x0E,0x0C,0x0C,0x0C,
	0x1C,0x1C,0x18,0x1C,0x1C,0x1C,0x0C,0x0C,0x0C,0x0E,0x06,0x06,0x07,0x03,0x03,0x01,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*"C:\Users\zjh46\Desktop\2.BMP",0*/
};

struct oled96_device {
    dev_t devid;
    struct cdev cdev;
    struct class *class;
    struct device *device;
    struct device_node *nd;
    void *private_data;
    int cs_gpio; /* chip selection gpio id */
    int reset_gpio;
    int dc_gpio;
};

static struct oled96_device oled96_dev;

static s32 oled96_write_regs(struct oled96_device *dev, u8 *buf, u8 len)
{
	int ret;
	struct spi_message msg;
	struct spi_transfer t;
	struct spi_device *spi = (struct spi_device *) dev->private_data;

#ifdef CS_GPIO
	gpio_set_value(dev->cs_gpio, 0); /* Low active */
#endif
	t.tx_buf = buf;
	t.len = len;
	spi_message_init(&msg);
	spi_message_add_tail(&t, &msg);
	ret = spi_sync(spi, &msg);
#ifdef CS_GPIO
	gpio_set_value(dev->cs_gpio, 1); /* release */
#endif
	return ret;
}

static void oled96_write_reg(struct oled96_device *dev, u8 value, u8 cmd)
{
	/* dc active low */
	switch (cmd) {
		case OLED_DATA: 
		gpio_set_value(dev->dc_gpio, 1);
		break;
		case OLED_CMD:
		gpio_set_value(dev->dc_gpio, 0);
		break;
	}
	oled96_write_regs(dev, &value, 1);
	gpio_set_value(dev->dc_gpio, 1);
}

static void oled96_refresh(void)
{
	u8 i, n;
	for (i = 0; i != 8; ++i) {
		/* Set row, low col and high col start addr */
		oled96_write_reg(&oled96_dev, 0xb0 + i, OLED_CMD);
		oled96_write_reg(&oled96_dev, 0x00, OLED_CMD);
		oled96_write_reg(&oled96_dev, 0x10, OLED_CMD);
		for (n = 0; n != 128; ++n)
			oled96_write_reg(&oled96_dev, OLED_GRAM[n][i], OLED_DATA);
	}
}

static void oled96_clear(void)
{
	u8 i, n;
	for (i = 0; i != 8; ++i)
		for (n = 0; n != 128; ++n)
			OLED_GRAM[n][i] = 0;
	oled96_refresh();
}

static void oled96_draw_point(u8 x, u8 y)
{
	u8 i = y / 8;
	u8 m = y % 8;
	u8 n = 1 << m;
	OLED_GRAM[x][i] |= n;
}

static void oled96_draw_circle(u8 x, u8 y, u8 r)
{
	int a = 0;
	int b = r;
	int num;
	while (2 * b * b >= r * r) {
		oled96_draw_point(x + a, y - b);
		oled96_draw_point(x - a, y - b);
		oled96_draw_point(x + a, y + b);
		oled96_draw_point(x - a, y + b);

		oled96_draw_point(x + b, y - a);
		oled96_draw_point(x - b, y - a);
		oled96_draw_point(x + b, y + a);
		oled96_draw_point(x - b, y + a);

		++a;
		/* 计算画到圆心距离，一层一层的画圈，直到完成。*/
		num = a * a + b * b - r * r;
		if (num > 0) {
			--b;
			--a;
		}

	}
}

static void oled96_write_begin_point(u8 x, u8 y)
{
	/* set the begin addr of row, high and low col. */
	oled96_write_reg(&oled96_dev, 0xb0 + y, OLED_CMD);
	oled96_write_reg(&oled96_dev, ((x & 0xf0) >> 4) | 0x10, OLED_CMD);
	oled96_write_reg(&oled96_dev, (x & 0x0f) | 0x01, OLED_CMD);
}

/*
 * x0, y0: begin position
 * x1, y1: end position
 * bmp: picture arr
 */
static void oled96_show_picture(u8 x0, u8 y0, u8 x1, u8 y1, u8 bmp[])
{
	u32 j = 0;
	u8 x = 0, y = 0;
	y = y % 8 == 0 ? 0 : (y + 1);
	for (y = y0; y != y1; ++y) {
		oled96_write_begin_point(x0, y);
		for (x = x0; x != x1; ++x, ++j)
			oled96_write_reg(&oled96_dev, bmp[j], OLED_DATA);
	}
}

static int oled96_open(struct inode *inode, struct file *filp)
{
	filp->private_data = &oled96_dev;
	return 0;
}

static int oled96_read(struct file *filp, char __user *buf, size_t cnt, loff_t *off)
{
	return 0;
}

static void oled96_draw_circle_demo(void)
{
	oled96_clear();
	oled96_draw_circle(72, 20, 20);
	oled96_refresh();
	printk("we have drawn a 20 circle\r\n");
}

static void oled96_show_picture_demo(void)
{
	oled96_clear();
	oled96_show_picture(0, 0, 128, 8, BMP2);
	printk("we have drawn a picture\r\n");
}

static ssize_t oled96_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *off)
{
	unsigned char databuf;
	unsigned char oled96stat;
	long err = 0;

	if (cnt > 1) {
		printk("write more than 1 count\r\n");
		return -EFAULT;
	}
	err = copy_from_user(&databuf, buf, cnt);
	if (err < 0) {
		printk("kernel write failed!\r\n");
		return -EFAULT;
	}
	oled96stat = databuf;
	/* we show contents with respect of the user input. */
	if (oled96stat == 0)
		oled96_draw_circle_demo();
	else
		oled96_show_picture_demo();
	return 0;
}

static int oled96_release(struct inode *inode, struct file *filp)
{
	return 0;
}

static const struct file_operations oled96_fops = {
	.owner = THIS_MODULE,
	.open = oled96_open,
	.read = oled96_read,
	.write = oled96_write,
	.release = oled96_release,
};

static void oled96_init_regs(struct oled96_device *dev)
{
	gpio_set_value(dev->reset_gpio, 1);
	mdelay(100);
	gpio_set_value(dev->reset_gpio, 0); /* activate reset now */
	mdelay(200);
	gpio_set_value(dev->reset_gpio, 1);

	/* transplant from stm32 examples */
	oled96_write_reg(&oled96_dev, 0xAE, OLED_CMD);
	oled96_write_reg(&oled96_dev, 0xAE,OLED_CMD);//--turn off oled panel
	oled96_write_reg(&oled96_dev, 0x00,OLED_CMD);//---set low column address
	oled96_write_reg(&oled96_dev, 0x10,OLED_CMD);//---set high column address
	oled96_write_reg(&oled96_dev, 0x40,OLED_CMD);//--set start line address  Set Mapping RAM Display Start Line (0x00~0x3F)
	oled96_write_reg(&oled96_dev, 0x81,OLED_CMD);//--set contrast control register
	oled96_write_reg(&oled96_dev, 0xCF,OLED_CMD);// Set SEG Output Current Brightness
	oled96_write_reg(&oled96_dev, 0xA1,OLED_CMD);//--Set SEG/Column Mapping     0xa0左右反置 0xa1正常
	oled96_write_reg(&oled96_dev, 0xC8,OLED_CMD);//Set COM/Row Scan Direction   0xc0上下反置 0xc8正常
	oled96_write_reg(&oled96_dev, 0xA6,OLED_CMD);//--set normal display
	oled96_write_reg(&oled96_dev, 0xA8,OLED_CMD);//--set multiplex ratio(1 to 64)
	oled96_write_reg(&oled96_dev, 0x3f,OLED_CMD);//--1/64 duty
	oled96_write_reg(&oled96_dev, 0xD3,OLED_CMD);//-set display offset	Shift Mapping RAM Counter (0x00~0x3F)
	oled96_write_reg(&oled96_dev, 0x00,OLED_CMD);//-not offset
	oled96_write_reg(&oled96_dev, 0xd5,OLED_CMD);//--set display clock divide ratio/oscillator frequency
	oled96_write_reg(&oled96_dev, 0x80,OLED_CMD);//--set divide ratio, Set Clock as 100 Frames/Sec
	oled96_write_reg(&oled96_dev, 0xD9,OLED_CMD);//--set pre-charge period
	oled96_write_reg(&oled96_dev, 0xF1,OLED_CMD);//Set Pre-Charge as 15 Clocks & Discharge as 1 Clock
	oled96_write_reg(&oled96_dev, 0xDA,OLED_CMD);//--set com pins hardware configuration
	oled96_write_reg(&oled96_dev, 0x12,OLED_CMD);
	oled96_write_reg(&oled96_dev, 0xDB,OLED_CMD);//--set vcomh
	oled96_write_reg(&oled96_dev, 0x40,OLED_CMD);//Set VCOM Deselect Level
	oled96_write_reg(&oled96_dev, 0x20,OLED_CMD);//-Set Page Addressing Mode (0x00/0x01/0x02)
	oled96_write_reg(&oled96_dev, 0x02,OLED_CMD);//
	oled96_write_reg(&oled96_dev, 0x8D,OLED_CMD);//--set Charge Pump enable/disable
	oled96_write_reg(&oled96_dev, 0x14,OLED_CMD);//--set(0x10) disable
	oled96_write_reg(&oled96_dev, 0xA4,OLED_CMD);// Disable Entire Display On (0xa4/0xa5)
	oled96_write_reg(&oled96_dev, 0xA6,OLED_CMD);// Disable Inverse Display On (0xa6/a7) 
	oled96_write_reg(&oled96_dev, 0xAF,OLED_CMD);
	oled96_clear();
}

static void oled96_set_gpio_direction(void)
{
#ifdef CS_GPIO
	if (gpio_direction_output(oled96_dev.cs_gpio, 1) < 0)
		printk("could not set cs_gpio\r\n");
#endif
	pr_info("set gpio direction of reset_gpio[%d], dc_gpio[%d]\r\n", oled96_dev.reset_gpio, oled96_dev.dc_gpio);
	if (gpio_direction_output(oled96_dev.reset_gpio, 1) < 0)
		printk("could not set reset_gpio\r\n");
	if (gpio_direction_output(oled96_dev.dc_gpio, 1) < 0)
		printk("could not set dc_gpio\r\n");
}

static int oled96_init_gpio_from_device_node(void)
{
	pr_info("init gpios\r\n");
#ifdef CS_GPIO
	oled96_dev.cs_gpio = of_get_named_gpio(oled96_dev.nd, "cs-gpio", 0);
	if (oled96_dev.cs_gpio < 0) {
		printk("count not get cs-gpio\r\n");
		return -EINVAL;
	}
#endif
	oled96_dev.reset_gpio = of_get_named_gpio(oled96_dev.nd, "reset-gpio", 0);
	if (oled96_dev.reset_gpio < 0) {
		printk("could not get reset-gpio\r\n");
		return -EINVAL;
	}
	oled96_dev.dc_gpio = of_get_named_gpio(oled96_dev.nd, "dc-gpio", 0);
	if (oled96_dev.dc_gpio < 0) {
		printk("could not get dc-gpio\r\n");
		return -EINVAL;
	}

	oled96_set_gpio_direction();
	return 0;
}

static int oled96_probe(struct spi_device *spi)
{
	alloc_chrdev_region(&oled96_dev.devid, 0, OLED96_COUNT, OLED96_NAME);

	cdev_init(&oled96_dev.cdev, &oled96_fops);
	cdev_add(&oled96_dev.cdev, oled96_dev.devid, OLED96_COUNT);

	oled96_dev.class = class_create(OLED96_NAME);
	if (IS_ERR(oled96_dev.class))
		return PTR_ERR(oled96_dev.class);

	oled96_dev.device = device_create(oled96_dev.class, 
			NULL, oled96_dev.devid, NULL, OLED96_NAME);
	if (IS_ERR(oled96_dev.device))
		return PTR_ERR(oled96_dev.device);

	pr_info("find node of spi\r\n");
	// oled96_dev.nd = of_find_node_by_path("/spi1/");
	oled96_dev.nd = of_find_node_by_name(NULL, "oled96spi");
	if (!oled96_dev.nd) {
		printk("could not find node[oled96spi]\r\n");
		return -EINVAL;
	}
	oled96_dev.nd = of_get_parent(oled96_dev.nd);
	if (!oled96_dev.nd) {
		printk("could not find node[spi1]\r\n");
		return -EINVAL;
	}

	if (oled96_init_gpio_from_device_node() == -EINVAL)
		return -EINVAL;

	spi->mode = SPI_MODE_0;
	spi_setup(spi);
	oled96_dev.private_data = spi;

	oled96_init_regs(&oled96_dev);
	oled96_draw_circle(72, 30, 30);
	oled96_refresh();
	printk("draw a circle\r\n");
	return 0;
}

static void oled96_remove(struct spi_device *spi)
{
	cdev_del(&oled96_dev.cdev);
	unregister_chrdev_region(oled96_dev.devid, OLED96_COUNT);
	device_destroy(oled96_dev.class, oled96_dev.devid);
	class_destroy(oled96_dev.class);
}

static const struct spi_device_id oled96_ids[] = {
	{ "oled96spi", 0},
	{}
};
// MODULE_DEVICE_TABLE(spi, oled96_ids);

static const struct of_device_id oled96_of_matchs[] = {
	{ .compatible = "yumi,oled96spi" },
	{}
};
// MODULE_DEVICE_TABLE(of, oled96_of_matchs);

static struct spi_driver oled96_driver = {
	.probe = oled96_probe,
	.remove = oled96_remove,
	.driver = {
		.owner = THIS_MODULE,
		.name = "oled96spi",
		.of_match_table = oled96_of_matchs,
	},
	.id_table = oled96_ids,
};

module_spi_driver(oled96_driver);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("wujing");
